# GameCenter テスト戦略と計画

このドキュメントは、GameCenter プロジェクトにおけるテストの方針、種類、範囲、および実行方法を定義します。

## 1. テストの目的

-   **品質保証:** ソフトウェアが要件を満たし、期待通りに動作することを保証します。
-   **回帰防止:** コード変更が既存の機能に悪影響を与えないことを確認します。
-   **信頼性向上:** システム全体の安定性と堅牢性を高めます。
-   **開発効率の向上:** 早期に問題を検出し、デバッグコストを削減します。

## 2. テストの種類と範囲

GameCenter プロジェクトでは、以下のテストレベルを組み合わせて品質を保証します。

### 2.1 単体テスト (Unit Test)

-   **目的:** 個々の関数、メソッド、モジュールが正しく動作することを確認します。
-   **対象:** 各コンポーネント内の最小単位のロジック。
-   **ツール:**
    -   **Game Engine (Rust):** `cargo test` (Rust標準のテストフレームワーク)
    -   **Sample Game (Python):** `pytest` (別途インストールが必要)
    -   **Frontend (Svelte):** `Vitest` (SvelteKitプロジェクトにデフォルトで含まれることが多い) または `Playwright` のコンポーネントテスト
-   **実行方法:** 各コンポーネントのディレクトリで対応するコマンドを実行します。

### 2.2 結合テスト (Integration Test)

-   **目的:** 複数のモジュールやコンポーネントが連携して正しく動作することを確認します。
-   **対象:**
    -   Game EngineとPythonゲーム間のHTTP通信 (`/game/init`, `/game/event` など)
    -   Game EngineとFrontend間のWebSocket通信 (`create_room`, `realtime_action` など)
-   **ツール:** 各言語のHTTP/WebSocketクライアントライブラリ (例: Rustの `reqwest`, Pythonの `requests`, JavaScriptの `WebSocket` API)
-   **実行方法:** 関連するコンポーネントを起動した状態で、テストコードを実行します。

### 2.3 エンドツーエンドテスト (End-to-End Test / E2E Test)

-   **目的:** システム全体がユーザーシナリオに沿って正しく動作することを確認します。
-   **対象:** クライアントのUI操作から、Game Engine、ゲームソフト、そしてクライアントへのフィードバックまでの一連のフロー。
-   **ツール:** `Playwright` (SvelteKitプロジェクトに組み込み可能)
-   **実行方法:** 全てのコンポーネントを起動した状態で、Playwrightのテストスクリプトを実行します。

## 3. テストの実行方法

-   **ローカルでの実行:** 各コンポーネントのディレクトリで、対応するテストコマンドを実行します。
    -   Rust: `cargo test`
    -   Python: `pytest`
    -   Svelte: `npm test` (または `npm run test:unit`, `npm run test:e2e` など、プロジェクト設定による)
-   **CI/CDパイプラインでの自動実行:**
    -   コードがリポジトリにプッシュされた際、自動的にテストが実行されるようにCI/CDツール (例: GitHub Actions, GitLab CI) を設定します。

## 4. テストデータ管理

-   **モック/スタブ:** 外部依存（データベース、外部APIなど）をシミュレートするために、モックやスタブを使用します。
-   **テストデータの生成:** テストの独立性と再現性を保つため、テストごとに必要なデータを生成または準備します。

## 5. テストカバレッジ

-   **目標:** 主要なビジネスロジックおよびAPIエンドポイントについては、高いテストカバレッジを目指します。
-   **計測ツール:** 各言語に対応したカバレッジ計測ツール (例: Rustの `grcov`, Pythonの `coverage.py`, JavaScriptの `c8`) を利用し、定期的にカバレッジを測定します。

## 6. テストのベストプラクティス

-   **テスト容易性の高いコード設計:** 依存関係を疎結合にし、単一責任の原則に従うことで、テストしやすいコードを記述します。
-   **テストの命名規則:** テストの目的が明確にわかるような命名規則を採用します。
-   **テストの独立性:** 各テストは他のテストに依存せず、独立して実行できるようにします。
-   **高速なフィードバック:** 単体テストは高速に実行できるようにし、開発サイクルを妨げないようにします。