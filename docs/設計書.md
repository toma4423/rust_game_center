# リアルタイム低遅延ゲーム機本体 設計書 (v2.1)

> **更新履歴:**
> - v2.1 (2025-09-07): 将来の拡張性に関する項目を追加。アーキテクチャ図を追記。
> - v2.0 (2025-09-07): 現状の実装に合わせてAPI仕様を更新、実装ステータスを反映。
> - v1.0 (2025-09-06): 初期設計。

## 1. 概要

（変更なし）

## 2. アーキテクチャ

### 2.1 コンポーネント

本プロジェクトは、以下の3つの主要コンポーネントで構成されています。

1.  **Game Engine (`/game-engine`)**
    -   **役割:** プロジェクトの中核。リアルタイム処理、ルーム管理、クライアントとのWebSocket通信、ゲームソフトとのHTTP API通信を担当します。
    -   **技術スタック:** Rust, Axum, Tokio, Tokio-Tungstenite

2.  **Game Software (`/games`)**
    -   **役割:** 個別のゲームルールやロジックを実装します。HTTP APIを介してゲーム機本体と連携します。
    -   **技術スタック:** 任意の言語（サンプルとしてPython + Flaskを使用）

3.  **Frontend (`/frontend`)**
    -   **役割:** プレイヤーが操作するWebクライアント。ゲーム機本体とWebSocketで通信します。
    -   **技術スタック:** Svelte, SvelteKit, TypeScript

### 2.2 通信フロー

```mermaid
graph TD
    subgraph Players
        A[Player 1 Browser]
        B[Player 2 Browser]
    end

    subgraph Game Software
        D(Python/Flask Server)
    end

    C[Game Engine (Rust Server)]

    A -- WebSocket --> C
    B -- WebSocket --> C
    C -- HTTP API --> D
    D -- HTTP API --> C
```

## 3. 機能要件

（変更なし）

## 4. データ構造

（v2.0から変更なし）

## 5. API設計

### 5.1 プレイヤー ↔ ゲーム機本体（WebSocket）

クライアントとサーバー間のメイン通信路。プレイヤーのアクションを受け付け、ゲーム全体の同期された状態を全プレイヤーに配信します。

#### 5.1.1 クライアント → サーバー
- **`create_room`**: 新しいルームを作成します。
- **`join_room`**: 既存のルームに参加します。
- **`select_game`**: ルームのホストがプレイするゲームを選択します。
- **`start_game`**: ホストがゲームの開始を宣言します。
- **`realtime_action`**: 早押しなど、リアルタイム性が要求されるアクションを送信します。

#### 5.1.2 サーバー → クライアント
- **`room_update`**: プレイヤーの参加/退出、ゲーム選択、状態変化など、ルーム全体の最新状態を通知します。これが状態同期の基本メッセージとなります。
- **`game_state`**: ゲーム固有のUI更新（例: 回答者表示）など、特定のフェーズにおける状態を通知します。
- **`broadcast_event`**: ゲームソフトからの要求に基づき、問題表示など、全プレイヤーに同時に通知したいイベントを配信します。
- **`error`**: 操作の失敗などを通知します。

### 5.2 ゲーム機本体 ↔ ゲームソフト（HTTP API）

ゲーム機本体のリアルタイム処理と、各ゲームソフトの固有ロジックを分離するための連携インターフェースです。

> **[重要]**
> すべてのリクエスト/レスポンスにおいて、どのルームに対する操作かを識別するため、ボディに `room_id` を含める仕様としています。

#### 5.2.1 ゲーム機本体 → ゲームソフト
- **`POST /game/init`**: ゲーム開始時に、参加プレイヤー情報などを渡してゲームの初期化を要求します。
- **`POST /game/event`**: プレイヤーのリアルタイムアクション（早押しなど）が発生したことをゲームソフトに通知します。

#### 5.2.2 ゲームソフト → ゲーム機本体
- **`POST /realtime/broadcast`**: 全プレイヤーにイベントを同時配信するよう要求します。
- **`POST /realtime/enable_action`**: 早押しなどのリアルタイムアクションの受付状態を制御するよう要求します。
- **`POST /game/next_phase`**: ゲームの次のフェーズへの移行と、それに伴うUIの更新を要求します。

## 6. 将来の拡張性

現在のアーキテクチャは、今後の機能拡張を見据えて設計されています。以下は、将来のバージョンで実装が検討される機能です。

- **タイマー制御機能:**
    - ゲームソフトが `start_timer` APIを呼び出すことで、サーバーサイドで正確なタイマー（カウントダウン等）を実行します。
    - タイムアウト時には、指定されたアクション（例: `timer_expired` イベントの通知）を自動で実行します。
    - クライアントには `timer_update` メッセージで残り時間を定期的に通知します。
- **ターン制管理機能:**
    - `TurnAction` を実装し、現在のターンプレイヤーのみがアクションを送信できるように制御します。
    - ゲームソフトは、APIを通じてターン順の変更や、次のターンへの移行を要求できます。
- **動的なUI更新API:**
    - ゲームソフトが、より柔軟にクライアントのUI（スコアボード、ボタンの有効/無効など）を更新するための `update_ui` APIを実装します。
- **ゲームの動的検出:**
    - サーバー起動時に `games` ディレクトリをスキャンし、利用可能なゲームのリスト (`/game/info` APIを持つサーバー) を自動で構築します。
    - クライアントは `available_games` メッセージを通じて、プレイ可能なゲームの一覧を取得できます。
- **ルーム設定の動的変更:**
    - `update_settings` メッセージを実装し、クライアントがルームの参加人数上限などを変更できるようにします。

## 7. 開発ステータスと今後のロードマップ

### 7.1 実装済み
- **Phase 1: ゲーム機本体基盤**
    - [x] Rust WebSocketサーバー構築
    - [x] 基本ルーム管理機能
    - [x] リアルタイム判定エンジン実装 (FirstPressのみ)
    - [x] シンプルなWebクライアント
- **Phase 2: ゲームソフト連携**
    - [x] HTTP API実装
    - [x] ゲーム選択システム (ハードコードで実装)
    - [x] サンプルゲームソフト（早押しクイズ）

### 7.2 今後のロードマップ (未実装)
- **設定管理システム:** ゲーム固有設定の管理機能。
- **多言語対応:** Kotlin, TypeScriptなど、Python以外の言語でのサンプルゲーム開発とガイド整備。
- **最適化・拡張:** 性能チューニング、UI/UX改善、監視機能、上記「6. 将来の拡張性」で挙げた機能の実装。