# ゲームソフト開発ガイド (v2.1)
## GameCenter ゲーム機本体 連携仕様書

> **バージョン情報:**
> - **本書のバージョン:** v2.1 (2025-09-07)
> - **対応するゲーム機本体のバージョン:** v0.1.0

---

## 📋 このガイドについて

このガイドは **GameCenter ゲーム機本体** 用のゲームソフトを開発するための仕様書です。

---

## 🎯 必須実装項目チェックリスト

ゲームソフトとしてゲーム機本体に認識・連携されるために、以下のAPIを実装してください。

- `POST /game/init`: ゲーム開始時に呼び出されます。
- `POST /game/event`: プレイヤーのリアルタイムアクション発生時に呼び出されます。
- `POST /game/timer_expired`: (将来実装予定) タイマー満了時に呼び出されます。
- `GET /game/info`: (将来実装予定) ゲーム機本体がゲーム情報を取得するために使用します。

---

## 🔧 API実装仕様 (ゲームソフト側)

ゲームソフトが実装すべきHTTP APIエンドポイントの仕様です。

### 1. ゲーム機本体との通信設定
- **URL**: ゲーム機本体のURLは、環境変数 `GAME_ENGINE_API_BASE` で渡されます。デフォルトは `http://localhost:3000` です。
- **プロトコル**: HTTP/JSON
- **タイムアウト**: 500ms以下の応答を推奨します。

### 2. 必須エンドポイント

#### POST /game/init
ゲーム開始時にゲーム機本体から呼び出されます。

```json
// リクエスト（ゲーム機本体 → ゲームソフト）
{
  "room_id": "12345",
  "players": [
    {"id": "player1_uuid", "display_name": "プレイヤー1"},
    {"id": "player2_uuid", "display_name": "プレイヤー2"}
  ],
  "settings": {}
}

// レスポンス（ゲームソフト → ゲーム機本体）
// 現在の実装ではレスポンスボディは使用されませんが、将来的にUIの初期化などに利用される可能性があります。
{
  "status": "success"
}
```

#### POST /game/event
プレイヤーのリアルタイムアクション（早押しなど）が発生した際に呼び出されます。

```json
// リクエスト（ゲーム機本体 → ゲームソフト）
{
  "room_id": "12345",
  "data": {
    "action": "first_press",
    "winner": "player1_uuid"
  }
}

// レスポンス（ゲームソフト → ゲーム機本体）
{
  "status": "event_handled"
}
```

#### POST /game/timer_expired (将来実装予定)
タイマーが満了した際に呼び出されます。

---

## 🚀 ゲーム機本体API活用 (ゲームソフト側から呼び出すAPI)

ゲームソフトからゲーム機本体の機能を呼び出すことで、ゲームを進行させることができます。

### 1. リアルタイム機能の制御

#### 同時配信でイベント送信
全プレイヤーに同時に情報を表示したい場合（問題表示など）に使用します。
```python
# POST /realtime/broadcast
requests.post(f'{GAME_ENGINE_URL}/realtime/broadcast', 
  json={
    "room_id": "12345",
    "event_type": "question_display",
    "data": {"question": "日本で一番高い山は？"}
  }
)
```

#### リアルタイムアクションの有効化
早押しボタンなど、プレイヤーからのアクション受付を開始/終了します。
```python
# POST /realtime/enable_action
requests.post(f'{GAME_ENGINE_URL}/realtime/enable_action', 
  json={
    "room_id": "12345",
    "action_type": "first_press",
    "enabled": True
  }
)
```

#### タイマー開始 (将来実装予定)
指定した時間でカウントダウンを開始します。
```python
# POST /realtime/start_timer
requests.post(f'{GAME_ENGINE_URL}/realtime/start_timer', 
  json={
    "room_id": "12345",
    "timer_id": "answer_time",
    "duration": 30
  }
)
```

### 2. ゲーム状態の更新

#### ゲームフェーズ変更
ゲームの状態（フェーズ）を更新し、クライアントのUI表示を変化させます。
```python
# POST /game/next_phase
requests.post(f'{GAME_ENGINE_URL}/game/next_phase', 
  json={
    "room_id": "12345",
    "phase": "answering",
    "ui_data": {
        "message": "Player1が回答中です！",
        "winner": "player1_uuid"
    }
  }
)
```

#### UIの動的更新 (将来実装予定)
ゲーム機本体に、より詳細なUI更新を指示するAPIです。

---

## 📝 実装例 (Python / Flask)

`games/quiz/app.py` として実装されているサンプルコードです。

```python
import os
from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

# ゲーム機本体のAPIエンドポイント
GAME_ENGINE_URL = os.environ.get("GAME_ENGINE_API_BASE", "http://localhost:3000")

# 簡単なインメモリ状態管理
game_state = {}

def send_to_game_engine(endpoint, data):
    """ゲーム機本体にリクエストを送信するヘルパー関数"""
    try:
        url = f"{GAME_ENGINE_URL}{endpoint}"
        print(f"Sending request to {url} with data: {data}")
        response = requests.post(url, json=data)
        response.raise_for_status()
        print(f"Successfully sent request to {endpoint}")
    except requests.exceptions.RequestException as e:
        print(f"Error sending request to {endpoint}: {e}")

@app.route("/game/init", methods=["POST"])
def init_game():
    data = request.json
    room_id = data.get("room_id")
    if not room_id:
        return "room_id is required", 400

    print(f"Initializing game for room {room_id}")
    game_state[room_id] = {"winner": None, "question": "Rustで最も人気のあるWebフレームワークは？"}

    # 1. 問題を全員に表示するようリクエスト
    send_to_game_engine("/realtime/broadcast", {
        "room_id": room_id,
        "event_type": "question_display",
        "data": {"question": game_state[room_id]["question"]}
    })

    # 2. 早押しアクションを有効にするようリクエスト
    send_to_game_engine("/realtime/enable_action", {
        "room_id": room_id,
        "action_type": "first_press",
        "enabled": True
    })
    
    return jsonify({"status": "initialized"})

@app.route("/game/event", methods=["POST"])
def handle_event():
    data = request.json
    room_id = data.get("room_id")
    event_data = data.get("data", {})
    
    if not room_id:
        return "room_id is required", 400

    print(f"Received event for room {room_id}: {data}")

    if event_data.get("action") == "first_press":
        winner_id = event_data.get("winner")
        if winner_id:
            game_state.setdefault(room_id, {})["winner"] = winner_id
            print(f"Winner in room {room_id} is {winner_id}")

            # 回答フェーズに移行するようリクエスト
            send_to_game_engine("/game/next_phase", {
                "room_id": room_id,
                "phase": "answering",
                "ui_data": {
                    "message": f"Player {winner_id} is answering!",
                    "winner": winner_id
                }
            })

    return jsonify({"status": "event_handled"})

if __name__ == "__main__":
    # ゲームソフトは5001番ポートで起動
    app.run(host="0.0.0.0", port=5001, debug=True)
```
